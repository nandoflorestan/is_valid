"""Concatenation of files in the directory is_valid/. Autogenerated."""
from collections import defaultdict
from datetime import datetime, date, time, timedelta
import json
import re

def _dictify(value, include_valid):
    if isinstance(value, Explanation):
        return value.dict(include_valid=include_valid)
    if isinstance(value, list):
        return [_dictify(v, include_valid) for v in value]
    if isinstance(value, dict):
        return {k: _dictify(v, include_valid) for k, v in value.items()}
    if isinstance(value, tuple):
        return tuple(_dictify(v, include_valid) for v in value)
    return value


def merge(*explanations):
    if any(not explanation for explanation in explanations):
        explanations = [
            explanation
            for explanation in explanations
            if not explanation
        ]
        valid = False
    else:
        valid = True

    details = defaultdict(list)
    merged_explanations = []

    for explanation in explanations:
        if explanation.code in ['dict_where', 'not_dict_where']:
            for key, value in explanation.details.items():
                details[key].append(value)
        elif explanation.code in ['all_hold', 'not_all_hold']:
            merged_explanations.extend(explanation.details)
        else:
            merged_explanations.append(explanation)

    if details:
        merged_explanations.append(Explanation(
            valid,
            'dict_where' if valid else 'not_dict_where',
            (
                'data is a dict where all the given predicates hold'
                if valid else
                'data is not a dict where all the given predicates hold'
            ),
            {
                key: merge(*explanations)
                for key, explanations in details.items()
            },
        ))

    if not merged_explanations:
        raise ValueError('Cannot merge 0 explanations')

    if len(merged_explanations) == 1:
        return merged_explanations[0]

    return Explanation(
        valid,
        'all_hold' if valid else 'not_all_hold',
        (
            'all of the given predicates hold'
            if valid else
            'at least one of the given predicates does not hold'
        ),
        merged_explanations,
    )


class Explanation:

    def __init__(self, valid, code, message, details=None):
        self.valid = valid
        self.code = code
        self.message = message
        self.details = details

    def summary(self):
        res = 'Data is valid.\n' if self.valid else 'Data is not valid.\n'
        for path, subexplanation in self.by_path():
            if path:
                prefix = '[{}] '.format(':'.join(map(repr, path)))
            else:
                prefix = ''
            res += '\n' + subexplanation.__summary(prefix)
        return res

    def __summary(self, prefix=''):
        if hasattr(self, 'data'):
            if self.message.startswith('data '):
                message = '{!r} {}' .format(self.data, self.message[4:])
            else:
                message = '{} ({!r})' .format(self.message, self.data)
        else:
            message = self.message
        return prefix + message

    def __str__(self):
        return self.__summary()

    def __bool__(self):
        return self.valid

    def __invert__(self):
        return Explanation(
            not self.valid, self.code, self.message, self.details
        )

    def dict(
        self, include_valid=False, include_details=True, include_data=True,
    ):
        res = {
            'code': self.code,
            'message': self.message,
        }
        if include_data and hasattr(self, 'data'):
            res['data'] = self.data
        if include_details and self.details is not None:
            res['details'] = _dictify(self.details, include_valid)
        if include_valid:
            res['valid'] = self.valid
        return res

    def list(
        self, include_valid=False, include_details=True, include_data=True,
        prefix=(),
    ):
        alist = []
        for path, explanation in self.by_path(prefix):
            adict = explanation.dict(
                include_valid=include_valid,
                include_details=include_details,
                include_data=include_data,
            )
            adict['path'] = path
            alist.append(adict)
        return alist

    def json(self, *args, include_valid=False, include_details=True, **kwargs):
        return json.dumps(self.dict(
            include_valid=include_valid,
            include_details=include_details,
        ), *args, **kwargs)

    def copy(self, **kwargs):
        res = Explanation(
            valid=kwargs.pop('valid', self.valid),
            code=kwargs.pop('code', self.code),
            message=kwargs.pop('message', self.message),
            details=kwargs.pop('details', self.details),
        )

        if hasattr(self, 'data'):
            res.data = self.data

        for key, value in kwargs.items():
            setattr(res, key, value)

        return res

    def by_path(self, prefix=()):
        if self.code in [
            'all_hold', 'not_all_hold',
            'none_hold', 'multiple_hold',
        ]:
            for subexp in self.details:
                yield from subexp.by_path(prefix)
        elif self.code in ['dict_of', 'not_dict_of']:
            for key, subexp in self.details.items():
                for subsubexp in subexp.values():
                    yield from subsubexp.by_path((*prefix, key))
        elif self.code in [
            'dict_where', 'not_dict_where',
            'iterable_of', 'not_iterable_of',
            'iterable_where', 'not_iterable_where',
            'object_where', 'not_object_where',
            'subdict_where', 'not_subdict_where',
            'set_of', 'not_set_of',
            'superdict_where', 'not_superdict_where',
        ]:
            for key, subexp in self.details.items():
                yield from subexp.by_path((*prefix, key))
        elif self.code == 'one_holds':
            yield prefix, self.details
        else:
            yield prefix, self

    def __add__(self, other):
        if not isinstance(other, Explanation):
            raise TypeError
        return merge(self, other)
def identity(value):
    return value


class Get(object):

    def __init__(self, key, transform=identity, rep=None):
        self._key = key
        self._transform = transform
        self._rep = str(key) if rep is None else rep

    def __repr__(self):
        return self._rep



class Predicate(object):

    prerequisites = []

    def _evaluate(self, data, explain, context):
        return (
            self._evaluate_explain
            if explain else
            self._evaluate_no_explain
        )(data, context)

    def _evaluate_explain(self, data, context):
        raise NotImplementedError('evaluate_explain is not implemented.')

    def _evaluate_no_explain(self, data, context):
        raise NotImplementedError('evaluate_no_explain is not implemented.')

    def __call__(self, data, explain=False, context={}):
        if not isinstance(context, Context):
            context = Context(context)

        try:
            for prerequisite in self.prerequisites:
                res = prerequisite(data, explain, context)
                if explain:
                    data = res.data
                if not res:
                    break
            else:
                res = self._evaluate(data, explain, context)
        except ContextError as e:
            res = e.explanation if explain else False

        if explain and not hasattr(res, 'data'):
            res = res.copy(data=data)
        return res

    def explain(self, data, context={}):
        return self(data, True, context)

    def __and__(self, other):
        return is_all(self, other)

    def __or__(self, other):
        return is_any(self, other)

    def __invert__(self):
        return is_not(self)


class ContextError(Exception):
    def __init__(self, key):
        self.explanation = Explanation(
            False, 'context_missing',
            'No context found for key \'{}\''.format(key),
        )
        super().__init__(self.explanation.message)


class Context(object):

    def __init__(self, base={}):
        self._values = defaultdict(list)
        for key, value in base.items():
            self.push(key, value)

    def push(self, key, value):
        self._values[key].append(value)

    def pop(self, key):
        self._values[key].pop()
        if not self._values[key]:
            del self._values[key]

    def __call__(self, value):
        if isinstance(value, Get):
            if not self._values[value._key]:
                raise ContextError(value._key)
            return value._transform(self._values[value._key][-1])
        return value


def instantiate(func):
    return func()


class is_eq(Predicate):
    """
    Generates a predicate that checks if the data is equal to the given value.
    The optional keyword argument ``rep`` specifies what the value should be
    called in the explanation. If no value for ``rep`` is given it will just
    use ``repr(value)``.
    """

    def __init__(self, value, rep=None):
        if rep is None:
            rep = repr(value)
        self._value = value
        self._valid_exp = Explanation(
            True, 'equal_to', 'data is equal to {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_equal_to', 'data is not equal to {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data == context(self._value) else
            (self._not_valid_exp if explain else False)
        )


def to_pred(value):
    if isinstance(value, Predicate):
        return value
    elif isinstance(value, dict):
        return is_dict_where(value)
    elif isinstance(value, list):
        return is_list_where(*value)
    elif isinstance(value, tuple):
        return is_tuple_where(*value)
    else:
        return is_eq(value)


class is_fixed(Predicate):
    """
    Generates a predicate that returns a certain value for valid, code, and
    message that it will always return regardless of what data you put into
    it.
    """

    def __init__(self, valid, code, message, details=None):
        self._valid = valid
        self._explanation = Explanation(valid, code, message, details)

    def _evaluate(self, data, explain, context):
        return self._explanation if explain else self._valid


def to_func(value):
    if callable(value):
        return value

    def function(*args, **kwargs):
        return value

    return function


def dict_to_func(context):
    context = {
        key: to_func(value)
        for key, value in context.items()
    }

    def func(*args, **kwargs):
        return {
            key: func(*args, **kwargs)
            for key, func in context.items()
        }

    return func


class is_with(Predicate):
    """
    A predicate that can set context that can then be retrieved using Get
    objects.
    """

    fail = is_fixed(False, 'set_failed', 'failed to set context')

    def __init__(self, context, success, fail=fail):
        if isinstance(context, dict):
            context = dict_to_func(context)
        self._context = to_func(context)
        self._success = to_pred(success)
        self._fail = to_pred(fail)

    def _get_subject(self, data, context):
        return data

    def _evaluate(self, data, explain, context):
        try:
            values = self._context(self._get_subject(data, context))
        except Exception:
            return self._fail(data, explain, context)
        else:
            for key, value in values.items():
                context.push(key, value)
            res = self._success(data, explain, context)
            for key in values:
                context.pop(key)
            return res


class is_with_context(is_with):

    def _get_subject(self, data, context):
        return {
            key: values[-1]
            for key, values in context._values.items()
        }


class explain(Predicate):
    """
    Wraps a predicate with an explanation. You can set the explanation messages
    with the parameters ``explanation_valid`` and ``explanation_invalid``.

    This method is also very nice way to use predicates from other sources than
    `Is Valid?` that don't have an ``explain`` parameter to work with
    explanations.
    """

    def __init__(
        self, predicate, code='valid',
        message_valid='data is valid', message_invalid='data is not valid',
        details_valid=None, details_invalid=None,
    ):
        if not callable(predicate):
            predicate = is_eq(predicate)
        self._context = isinstance(predicate, Predicate)
        self._predicate = predicate
        self._valid_exp = Explanation(
            True, code, message_valid, details_valid
        )
        self._not_valid_exp = Explanation(
            False, 'not_{}'.format(code), message_invalid, details_invalid
        )

    def _evaluate(self, data, explain, context):
        if self._context:
            valid = self._predicate(data, explain, context)
        else:
            valid = self._predicate(data)

        if explain:
            res = self._valid_exp if valid else self._not_valid_exp
            if self._context:
                res = res.copy()
                res.data = valid.data
            return res
        else:
            return bool(valid)


class Wrapper(Predicate):

    def __init__(self, wrapped=None):
        if wrapped is not None:
            wrapped = to_pred(wrapped)
        self._wrapped = wrapped

    def wrap(self, wrapped):
        wrapped = to_pred(wrapped)
        self._wrapped = wrapped
        return wrapped

    def _evaluate(self, data, explain, context):
        return self._wrapped(data, explain, context)


def default_context(pred, *args, **kwargs):
    """
    Wraps a predicate with default context.
    """
    defaults = dict(*args, **kwargs)

    def context_func(context):
        return {
            key: value
            for key, value in defaults.items()
            if key not in context
        }

    return is_with_context(context_func, pred)


class is_instance(Predicate):
    """
    Generates a predicate that checks if the data is an instance of the given
    class. You can use the ``rep`` argument to specify what an instance of this
    class should be called. If you don't do this it will default to ``an
    instance of {cls.__name__}``.
    """

    def __init__(self, cls, rep=None):
        if rep is None:
            rep = 'an instance of {}'.format(cls.__name__)
        self._cls = cls
        self._valid_exp = Explanation(
            True, 'instance_of', 'data is {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_instance_of', 'data is not {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if isinstance(data, context(self._cls)) else
            (self._not_valid_exp if explain else False)
        )


#: A predicate that checks if the data is a string.
is_str = is_instance(str, rep='a str')


class is_fixed(Predicate):
    """
    Generates a predicate that returns a certain value for valid, code, and
    message that it will always return regardless of what data you put into
    it.
    """

    def __init__(self, valid, code, message, details=None):
        self._valid = valid
        self._explanation = Explanation(valid, code, message, details)

    def _evaluate(self, data, explain, context):
        return self._explanation if explain else self._valid


#: A predicate that checks if the data is a dictionary.
is_dict = is_instance(dict, rep='a dict')


is_transformable = is_fixed(
    True, 'transformable', 'data can be transformed'
)

is_not_transformable = is_fixed(
    False, 'not_transformable', 'data can not be transformed'
)


class is_transformed(Predicate):
    """
    Generates a predicate that checks if the data is valid according to some
    predicate after a function has been applied to the data. If this function
    throws an exception the predicate will consider the data invalid.

    With the ``exceptions`` parameter you can limit the exceptions that the
    predicate catches. With the ``msg`` parameter you can specify what the
    explanation should be when the predicate catches an exception.

    All other arguments provided will be passed on to the transform function.
    """

    def __init__(
        self, transform, success=is_transformable, fail=is_not_transformable,
        exceptions=[Exception],
    ):
        self._transform = transform
        self._success = to_pred(success)
        self._fail = to_pred(fail)
        self._exceptions = exceptions

    def _evaluate(self, data, explain, context):
        try:
            data = self._transform(data)
        except Exception as e:
            if not any(isinstance(e, exc) for exc in self._exceptions):
                raise e
            return self._fail(data, explain, context)
        else:
            return self._success(data, explain, context)


#: A predicate that checks if the data is an integer.
is_int = is_instance(int, rep='an int')


#: A predicate that checks if the data is bytes.
is_bytes = is_instance(bytes, rep='bytes')


class is_decodable_where(is_transformed):

    prerequisites = [is_bytes]

    def __init__(self, predicate, encoding='utf-8', errors='strict'):
        super().__init__(
            lambda s: s.decode(encoding, errors), predicate,
            is_fixed(False, 'not_decodable', 'data is not decodable'),
            exceptions=[UnicodeDecodeError],
        )


#: A predicate that regardless of what data you put into will always consider
#: it valid with the explanation 'Ddata is something.'. This is the weakest
#: predicate possible.
is_something = is_fixed(True, 'is_something', 'data is something')


@instantiate
class is_iterable(Predicate):
    """
    A predicate that checks if the data is iterable.
    """

    def __init__(self):
        self._valid_exp = Explanation(True, 'iterable', 'Data is iterable.')
        self._not_valid_exp = Explanation(
            False, 'not_iterable', 'Data is not iterable.'
        )

    def _evaluate(self, data, explain, context):
        try:
            iter(data)
        except TypeError:
            return self._not_valid_exp if explain else False
        else:
            return self._valid_exp if explain else True


class is_iterable_of(Predicate):
    """
    Generates a predicate that checks that the data is an iterable where
    every element of the data is valid according to the given predicate.
    """

    prerequisites = [is_iterable]

    def __init__(self, predicate):
        self._predicate = to_pred(predicate)

    def _evaluate_explain(self, data, context):
        reasons = {}
        errors = {}
        new_data = []

        for i, value in enumerate(data):
            explanation = self._predicate.explain(value, context)
            if explanation:
                reasons[i] = explanation
            else:
                errors[i] = explanation
            new_data.append(explanation.data)

        if errors:
            explanation = Explanation(
                False, 'not_iterable_of',
                'not all elements are valid according to the predicate',
                errors,
            )
        else:
            explanation = Explanation(
                True, 'iterable_of',
                'all elements are valid according to the predicate',
                reasons,
            )
        explanation.data = new_data
        return explanation

    def _evaluate_no_explain(self, data, context):
        return all(
            self._predicate(value, context=context)
            for value in data
        )


class is_geq(Predicate):
    """
    Generates a predicate that checks if the data greater than or equal to the
    given value. The optional keyword argument ``rep`` specifies what the value
    should be called in the explanation. If no value for ``rep`` is given it
    will just use ``repr(value)``.
    """

    def __init__(self, value, rep=None):
        if rep is None:
            rep = repr(value)
        self._value = value
        self._valid_exp = Explanation(
            True, 'greater_than_or_equal_to',
            'data is greater than or equal to {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_greater_than_or_equal_to',
            'data is not greater than or equal to {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data >= context(self._value) else
            (self._not_valid_exp if explain else False)
        )


class is_leq(Predicate):
    """
    Generates a predicate that checks if the data lower than or equal to the
    given value. The optional keyword argument ``rep`` specifies what the value
    should be called in the explanation. If no value for ``rep`` is given it
    will just use ``repr(value)``.
    """

    def __init__(self, value, rep=None):
        if rep is None:
            rep = repr(value)
        self._value = value
        self._valid_exp = Explanation(
            True, 'lower_than_or_equal_to',
            'data is lower than or equal to {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_lower_than_or_equal_to',
            'data is not lower than or equal to {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data <= context(self._value) else
            (self._not_valid_exp if explain else False)
        )


class is_in_range(Predicate):
    """
    Generates a predicate that checks if the data is within the range specified
    by ``start`` and ``stop``. The optional arguments ``start_in`` and
    ``stop_in`` specify whether respectively ``start`` and ``stop`` should be
    included or excluded from the range.
    """

    def __init__(
        self, start, stop,
        start_in=True, stop_in=False, start_rep=None, stop_rep=None
    ):
        if start_rep is None:
            start_rep = repr(start)
        if stop_rep is None:
            stop_rep = repr(stop)
        self._start = (is_geq if start_in else is_gt)(start, rep=start_rep)
        self._stop = (is_leq if stop_in else is_lt)(stop, rep=stop_rep)
        self._valid_exp = Explanation(
            True, 'in_range',
            self._start._valid_exp.message + ' and ' +
            self._stop._valid_exp.message,
        )

    def _evaluate_explain(self, data, context):
        res = self._start.explain(data, context)
        if not res:
            return res
        res = self._stop.explain(data, context)
        if not res:
            return res
        return self._valid_exp

    def _evaluate_no_explain(self, data, context):
        return (
            self._start(data, context=context) and
            self._stop(data, context=context)
        )


class is_json_where(is_transformed):

    prerequisites = [is_str]

    def __init__(self, predicate, loader=json.loads):
        super().__init__(
            loader, predicate,
            is_fixed(False, 'not_json', 'data is not json'),
            exceptions=[ValueError],
        )


#: A predicate that regardless of what data you put into will always consider
#: it invalid with the explanation 'Data is something.'. This is the strongest
#: predicate possible.
is_nothing = is_fixed(False, 'is_something', 'data is something')



class is_dict_where(Predicate):
    """
    Generates a predicate that checks that the data is a dict where for every
    key the value corresponding to that key is valid according to the given
    predicate corresponding to that key. If the keys of the data and the keys
    of the given predicates do not match the data is considered invalid.

    The arguments for this function work exactly the same as that of the dict
    constructor.
    """

    prerequisites = [is_dict]

    _missing_exp = Explanation(False, 'missing', 'key is missing')
    _extra_pred = is_fixed(False, 'not_allowed', 'key is not allowed')

    def __init__(self, *args, **kwargs):
        self._predicates = defaultdict(lambda: self._extra_pred)

        if len(args) == 2 and len(kwargs) == 0:
            self._required = set(args[0])
            self._predicates.update(
                (key, to_pred(predicate))
                for key, predicate in args[0].items()
            )
            self._predicates.update(
                (key, to_pred(predicate))
                for key, predicate in args[1].items()
            )
        else:
            predicates = dict(*args, **kwargs)
            self._required = set(predicates)
            self._predicates.update(
                (key, to_pred(predicate))
                for key, predicate in predicates.items()
            )

    def _evaluate(self, data, explain, context):
        missing = {key for key in self._required if key not in data}

        if not explain:
            return not missing and all(
                self._predicates[key](value, context=context)
                for key, value in data.items()
            )

        reasons = {}
        errors = {}
        new_data = {}

        for key, value in data.items():
            explanation = self._predicates[key].explain(value, context)
            if explanation:
                reasons[key] = explanation
            else:
                errors[key] = explanation
            new_data[key] = explanation.data
        for key in missing:
            errors[key] = self._missing_exp

        if errors:
            explanation = Explanation(
                False, 'not_dict_where',
                'data is not a dict where all the given predicates hold',
                errors,
            )
        else:
            explanation = Explanation(
                True, 'dict_where',
                'data is a dict where all the given predicates hold',
                reasons,
            )
        explanation.data = new_data
        return explanation


class is_in(Predicate):
    """
    Generates a predicate that checks if the data is within the given
    collection.
    """

    def __init__(self, collection, rep='the collection'):
        self._collection = collection
        self._valid_exp = Explanation(
            True, 'in_collection',
            'data is in {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_in_collection',
            'data is not in {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data in context(self._collection) else
            (self._not_valid_exp if explain else False)
        )


class is_superdict_where(is_dict_where):
    """
    Generates a predicate that checks that the data is a dict where for every
    key the value corresponding to that key is valid according to the given
    predicate corresponding to that key. If not all of the keys in the given
    predicates are in the data the data is considered invalid.

    The arguments for this function work exactly the same as that of the dict
    constructor.
    """

    _extra_pred = is_something


class is_subdict_where(is_dict_where):
    """
    Generates a predicate that checks that the data is a dict where for every
    key the value corresponding to that key is valid according to the given
    predicate corresponding to that key. If not all of the keys in the data
    have a corresponding predicate the data is considered invalid.

    The arguments for this function work exactly the same as that of the dict
    constructor.
    """

    def __init__(self, *args, **kwargs):
        super().__init__({}, dict(*args, **kwargs))


class is_not(Predicate):
    """
    Generates the inverse of a given predicate. So if the given predicate would
    consider the data valid the generated predicate will consider it invalid,
    and the other way around. It reuses the explanation of the given predicate.
    """

    def __new__(cls, predicate):
        if isinstance(predicate, is_not):
            return predicate._predicate
        return super().__new__(cls)

    def __init__(self, predicate):
        self._predicate = to_pred(predicate)

    def _evaluate(self, data, explain, context):
        return (
            ~self._predicate.explain(data, context)
            if explain else
            not self._predicate(data, context=context)
        )


class is_all(Predicate):
    """
    Generates a predicate that will consider data valid if and only if all of
    the given predicates considers the data valid.
    """

    def __init__(self, *predicates):
        self._predicates = []
        for predicate in predicates:
            if isinstance(predicate, is_all):
                self._predicates.extend(predicate._predicates)
            else:
                self._predicates.append(to_pred(predicate))

    def _evaluate_explain(self, data, context):
        reasons, errors = [], []
        for predicate in self._predicates:
            explanation = predicate.explain(data, context)
            (reasons if explanation else errors).append(explanation)
        return Explanation(
            True, 'all_hold',
            'all of the given predicates hold',
            reasons,
        ) if not errors else Explanation(
            False, 'not_all_hold',
            'at least one of the given predicates does not hold',
            errors,
        )

    def _evaluate_no_explain(self, data, context):
        return all(
            predicate(data, context=context)
            for predicate in self._predicates
        )


class is_any(Predicate):
    """
    Generates a predicate that will consider data valid if and only if any of
    the given predicates considers the data valid.
    """

    def __init__(self, *predicates):
        self._predicates = []
        for predicate in predicates:
            if isinstance(predicate, is_any):
                self._predicates.extend(predicate._predicates)
            else:
                self._predicates.append(to_pred(predicate))

    def _evaluate_explain(self, data, context):
        reasons, errors = [], []
        for predicate in self._predicates:
            explanation = predicate.explain(data, context)
            (reasons if explanation else errors).append(explanation)
        return Explanation(
            True, 'any_holds',
            'at least one of the given predicates holds',
            reasons,
        ) if reasons else Explanation(
            False, 'not_any_holds',
            'none of the given predicates holds',
            errors,
        )

    def _evaluate_no_explain(self, data, context):
        return any(
            predicate(data, context=context)
            for predicate in self._predicates
        )


def blank(value):
    return not value


is_blank = explain(
    blank,
    code='blank',
    message_valid='data is blank',
    message_invalid='data is not blank',
)
is_not_blank = ~is_blank


#: A predicate that checks if the data is a boolean.
is_bool = is_instance(bool, rep='a bool')


@instantiate
class is_byte(is_in_range):

    prerequisites = [is_int]

    def __init__(self):
        super().__init__(0, 255, stop_in=True)


is_no_match = is_fixed(False, 'no_match', 'none of the conditions match')


def identity(data):
    return data


class is_cond(Predicate):
    """
    Generates a predicate that given pairs of condition and validation
    predicates (represented as 2-tuples) returns the result of the validation
    predicate that corresponds to the first condition predicate that holds
    for the given data. If none of the condition predicates hold the predicate
    with the ``default`` keyword argument will be used. By default this will
    always consider the data invalid with the explanation that the data matches
    none of the conditions.
    """

    def __init__(
        self, *conditions,
        cond_trans=identity, pred_trans=identity,
        default=is_no_match
    ):
        self._conditions = [
            (to_pred(c), to_pred(p))
            for c, p in conditions
        ]
        self._cond_trans = cond_trans
        self._pred_trans = pred_trans
        self._default = to_pred(default)

    def _evaluate(self, data, explain, context):
        cond_data = self._cond_trans(data)
        pred_data = self._pred_trans(data)
        for condition, predicate in self._conditions:
            if condition(cond_data, context=context):
                return predicate(pred_data, explain, context)
        return self._default(pred_data, explain, context)


#: A predicate that checks if the data is a date.
is_date = is_instance(date, rep='a date')


#: A predicate that checks if the data is a datetime.
is_datetime = is_instance(datetime, rep='a datetime')


class is_decodable(is_decodable_where):

    def __init__(self, encoding='utf-8', errors='strict'):
        super().__init__(
            is_fixed(True, 'decodable', 'data is decodable'),
            encoding, errors,
        )



class is_decodable_json_where(is_decodable_where):

    def __init__(
        self, predicate, loader=json.loads, encoding='utf-8', errors='strict'
    ):
        return super().__init__(
            is_json_where(predicate, loader=loader),
            encoding=encoding,
            errors=errors,
        )


class is_dict_of(Predicate):
    """
    Generates a predicate that checks that the data is a dict where every key
    is valid according to ``key_predicate`` and every value is valid according
    to ``val_predicate``.
    """

    prerequisites = [is_dict]

    def __init__(self, key_predicate, value_predicate):
        self._key = to_pred(key_predicate)
        self._value = to_pred(value_predicate)

    def _evaluate_explain(self, data, context):
        new_data = {}
        reasons = {}
        errors = {}

        for key, value in data.items():
            reason, error = {}, {}

            key_explanation = self._key.explain(key, context)
            if key_explanation:
                reason['key'] = key_explanation
            else:
                error['key'] = key_explanation

            value_explanation = self._value.explain(value, context)
            if value_explanation:
                reason['value'] = value_explanation
            else:
                error['value'] = value_explanation

            if error:
                errors[key] = error
            else:
                reasons[key] = reason

            new_data[key_explanation.data] = value_explanation.data

        if errors:
            explanation = Explanation(
                False, 'not_dict_of',
                'not all elements are valid according to the predicate',
                errors,
            )
        else:
            explanation = Explanation(
                True, 'dict_of',
                'all elements are valid according to the predicate',
                reasons,
            )
        explanation.data = new_data
        return explanation

    def _evaluate_no_explain(self, data, context):
        return all(
            self._key(key, context=context) and
            self._value(value, context=context)
            for key, value in data.items()
        )


class is_dict_union(Predicate):

    def __init__(self, *args, **kwargs):
        if args and isinstance(args[0], str):
            key = args[0]
            args = args[1:]
        else:
            key = 'type'
        self._key = key
        self._preds = {
            value: self._to_pred(pred, value)
            for value, pred in dict(*args, **kwargs).items()
        }
        self.prerequisites = [is_superdict_where({
            key: is_in(set(self._preds)),
        })]

    def _to_pred(self, pred, value):
        pred = to_pred(pred)

        if type(pred) in [is_dict_where, is_superdict_where, is_subdict_where]:
            if type(pred) is is_superdict_where:
                cls = is_superdict_where
            else:
                cls = is_dict_where

            required = {self._key: value}
            optional = {}
            for key, subpred in pred._predicates.items():
                if key in pred._required:
                    required[key] = subpred
                else:
                    optional[key] = subpred

            pred = cls(required, optional)

        elif type(pred) is is_dict_union:
            return is_dict_union(pred._key, {
                subvalue: self._to_pred(subpred, value)
                for subvalue, subpred in pred._preds.items()
            })

        return pred

    def _evaluate(self, data, explain, context):
        return self._preds[data[self._key]](data, explain, context)


#: A predicate that checks if the data is a float.
is_float = is_instance(float, rep='a float')


class is_gt(Predicate):
    """
    Generates a predicate that checks if the data is greater than the given
    value. The optional keyword argument ``rep`` specifies what the value
    should be called in the explanation. If no value for ``rep`` is given it
    will just use ``repr(value)``.
    """

    def __init__(self, value, rep=None):
        if rep is None:
            rep = repr(value)
        self._value = value
        self._valid_exp = Explanation(
            True, 'greater_than', 'data is greater than {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_greater_than',
            'data is not greater than {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data > context(self._value) else
            (self._not_valid_exp if explain else False)
        )


class is_if(Predicate):
    """
    Generates a predicate that given a predicate as condition will based on the
    result of this condition on the data evaluate the data with either
    ``if_predicate`` or ``else_predicate``. If else predicate is omitted it
    will use the value of ``else_valid`` for when the condition considers the
    data invalid, as explanation it will reuse the explanation that the
    condition returned.
    """

    def __init__(self, condition, if_predicate, *args, **kwargs):
        else_predicate = None

        if args:
            if len(args) > 1:
                raise TypeError(
                    '__init__() takes 4 positional arguments but {} were given'
                    .format(len(args) + 3)
                )
            else_predicate = to_pred(args[0])

        for key, value in kwargs.items():
            if key != 'else_predicate':
                raise TypeError(
                    '__init__() got an unexpected keyword argument {!r}'
                    .format(key)
                )
            elif else_predicate is not None:
                raise TypeError(
                    '__init__() got multiple values for argument '
                    '\'else_predicate\''
                )
            else_predicate = to_pred(value)

        self._cond = to_pred(condition)
        self._if = to_pred(if_predicate)
        self._else = else_predicate

    def _evaluate(self, data, explain, context):
        res = self._cond(data, explain, context)
        if explain:
            data = res.data
        if res:
            res = self._if(data, explain, context)
        elif self._else is not None:
            res = self._else(data, explain, context)
        else:
            res = ~res if explain else not res
        return res

    @classmethod
    def cases(cls, *cases, default=is_nothing):
        predicate = to_pred(default)
        for cond, then_ in reversed(cases):
            predicate = cls(cond, then_, predicate)
        return predicate


class is_iterable_where(Predicate):
    """
    Generates a predicate that checks that the data is an iterable where
    the 1st element of the data is valid according to the 1st given predicate,
    the 2nd element of the data is valid according to the 2nd given predicate
    and so on. Also requires that the amount of elements in the iterable is
    equal to the amount of predicates given.
    """

    prerequisites = [is_iterable]

    _overflow_exp = Explanation(False, 'overflow', 'data is overflowing')
    _missing_exp = Explanation(False, 'missing', 'data is missing')

    def __init__(self, *predicates):
        self._predicates = [to_pred(predicate) for predicate in predicates]

    def _evaluate(self, data, explain, context):
        data = list(data)
        if not explain:
            return len(data) == len(self._predicates) and all(
                predicate(value, context=context)
                for predicate, value in zip(self._predicates, data)
            )

        reasons = {}
        errors = {}
        new_data = []
        for i, (predicate, value) in enumerate(zip(self._predicates, data)):
            explanation = predicate.explain(value, context)
            if explanation:
                reasons[i] = explanation
            else:
                errors[i] = explanation
            new_data.append(explanation.data)
        for i in range(len(self._predicates), len(data)):
            errors[i] = self._overflow_exp
        for i in range(len(data), len(self._predicates)):
            errors[i] = self._missing_exp

        if errors:
            explanation = Explanation(
                False, 'not_iterable_where',
                'not all elements are valid according to their respective '
                'predicate',
                errors,
            )
        else:
            explanation = Explanation(
                True, 'iterable_where',
                (
                    'all elements are valid according to their respective '
                    'predicate'
                ),
                reasons,
            )
        explanation.data = new_data
        return explanation


is_json = is_json_where(is_fixed(True, 'json', 'data is json'))


#: A predicate that checks if the data is a list.
is_list = is_instance(list, rep='a list')


class is_list_of(is_iterable_of):
    """
    Generates a predicate that checks that the data is a list where every
    element of the data is valid according to the given predicate.
    """

    prerequisites = [is_list]


class is_list_where(is_iterable_where):
    """
    Generates a predicate that checks that the data is a list where the 1st
    element of the data is valid according to the 1st given predicate, the 2nd
    element of the data is valid according to the 2nd given predicate and so
    on. Also requires that the amount of elements in the list is equal to the
    amount of predicates given.
    """

    prerequisites = [is_list]


class is_lt(Predicate):
    """
    Generates a predicate that checks if the data is lower than the given
    value. The optional keyword argument ``rep`` specifies what the value
    should be called in the explanation. If no value for ``rep`` is given it
    will just use ``repr(value)``.
    """

    def __init__(self, value, rep=None):
        if rep is None:
            rep = repr(value)
        self._value = value
        self._valid_exp = Explanation(
            True, 'lower_than', 'data is lower than {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_lower_than', 'data is not lower than {}'.format(rep)
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data < context(self._value) else
            (self._not_valid_exp if explain else False)
        )


class is_match(Predicate):
    """
    A predicate that checks if the data matches the given pattern. If a string
    is provided as a pattern this predicate will compile it first. The
    optional parameter ``flags`` allows you to specify flags for this
    aforementioned compilation.
    """

    prerequisites = [is_str]

    def __init__(self, regex, flags=0, rep=None, match_as_data=False):
        if isinstance(regex, str):
            regex = re.compile(regex, flags)
        if rep is None:
            rep = '/{}/{}'.format(
                regex.pattern,
                ''.join(
                    char
                    for flag, char in [
                        (re.A, 'a'), (re.I, 'i'), (re.L, 'l'),
                        (re.M, 'm'), (re.S, 's'), (re.X, 'x'),
                    ]
                    if regex.flags & flag
                ),
            )
        self._regex = regex
        self._valid_exp = Explanation(
            True, 'match', 'data does match {}'.format(rep)
        )
        self._not_valid_exp = Explanation(
            False, 'not_match', 'data does not match {}'.format(rep)
        )
        self._match_as_data = match_as_data

    def _evaluate(self, data, explain, context):
        match = self._regex.search(data)
        if match:
            res = self._valid_exp if explain else True
            if explain and self._match_as_data:
                res = res.copy(data=match)
        else:
            res = self._not_valid_exp if explain else False
        return res


@instantiate
class is_none(Predicate):
    """
    A predicate that checks if the data is None.
    """

    def __init__(self):
        self._valid_exp = Explanation(True, 'none', 'data is None')
        self._not_valid_exp = Explanation(
            False, 'not_none', 'data is not None'
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data is None else
            (self._not_valid_exp if explain else False)
        )


@instantiate
class is_null(Predicate):
    """
    A predicate that checks if the data is None. Differs from ``is_none`` in
    it's explanation. This predicate will use the word `null` in it's
    explanation instead of `None`.
    """

    def __init__(self):
        self._valid_exp = Explanation(True, 'null', 'data is null')
        self._not_valid_exp = Explanation(
            False, 'not_null', 'data is not null'
        )

    def _evaluate(self, data, explain, context):
        return (
            (self._valid_exp if explain else True)
            if data is None else
            (self._not_valid_exp if explain else False)
        )


class is_nullable(Predicate):

    def __init__(self, predicate):
        self._predicate = to_pred(predicate)

    def _evaluate(self, data, explain, context):
        res = is_null(data, explain, context)
        if res:
            return res
        return self._predicate(data, explain, context)

#: A predicate that checks if the data is a number.
is_number = is_instance((int, float), rep='a number')


class is_object_where(Predicate):
    """
    Generates a predicate that checks that the data is an object where every
    given predicate holds for the associated attribute on the object.
    """

    _no_such_attr = Explanation(
        False, 'no_such_attr',
        'Data does not have this attribute',
    )

    def __init__(self, *args, **kwargs):
        self._predicates = {
            attr: to_pred(predicate)
            for attr, predicate in dict(*args, **kwargs).items()
        }

    def _evaluate_explain(self, data, context):
        reasons, errors = {}, {}
        for attr, predicate in self._predicates.items():
            if hasattr(data, attr):
                explanation = predicate.explain(getattr(data, attr), context)
                (reasons if explanation else errors)[attr] = explanation
            else:
                errors[attr] = self._no_such_attr
        return Explanation(
            True, 'object_where',
            'data is an object where all the given predicates hold',
            reasons,
        ) if not errors else Explanation(
            False, 'not_object_where',
            'data is not an object where all the given predicates hold',
            errors,
        )

    def _evaluate_no_explain(self, data, context):
        return all(
            hasattr(data, attr) and
            predicate(getattr(data, attr), context=context)
            for attr, predicate in self._predicates.items()
        )


class is_one(Predicate):
    """
    Generates a predicate that will consider data valid if and only if exactly
    one of the given predicates considers the data valid.
    """

    def __init__(self, *predicates):
        self._predicates = [to_pred(predicate) for predicate in predicates]

    def _evaluate_explain(self, data, context):
        reasons, errors = [], []
        for predicate in self._predicates:
            explanation = predicate.explain(data, context)
            (reasons if explanation else errors).append(explanation)
        return Explanation(
            True, 'one_holds',
            'exactly one of the given predicates hold',
            reasons[0],
         ) if len(reasons) == 1 else Explanation(
            False, 'none_hold',
            'none of the given predicates hold',
            errors,
         ) if len(reasons) == 0 else Explanation(
             False, 'multiple_hold',
            'multiple of the given predicates hold',
            reasons,
         )

    def _evaluate_no_explain(self, data, context):
        one = False
        for predicate in self._predicates:
            if predicate(data, context=context):
                if one:
                    return False
                one = True
        return one


class is_optional(Predicate):

    def __init__(self, predicate):
        self._predicate = to_pred(predicate)

    def _evaluate(self, data, explain, context):
        res = is_none(data, explain, context)
        if res:
            return res
        return self._predicate(data, explain, context)


class is_pre(Predicate):
    """
    Given some predicates this creates a predicate that will try to see if all
    the given predicates hold. This differs from `is_all` in that this
    predicate will stop evaluation after the first failure and will only return
    the result of the last predicate on success. This makes it very suitable
    for adding preconditions where you only want to use later predicates
    when you know the previous predicates hold.

    When no predicates are given the returned predicate will be equivalent to
    `is_something`.
    """

    _base_exp = Explanation(True, 'is_something', 'data is something')

    def __init__(self, *predicates):
        self._predicates = [to_pred(predicate) for predicate in predicates]

    def _evaluate(self, data, explain, context):
        valid = self._base_exp if explain else True
        for predicate in self._predicates:
            if not valid:
                break
            valid = predicate(data, explain, context)
            if explain:
                data = valid.data
        return valid


#: A predicate that checks if the data is a set.
is_set = is_instance(set, rep='a set')


class is_set_of(is_iterable_of):

    prerequisites = [is_set]

    def _evaluate_explain(self, data, context):
        data = list(data)
        explanation = super()._evaluate_explain(data, context)
        return Explanation(
            explanation.valid,
            'set_of' if explanation.valid else 'not_set_of',
            explanation.message,
            {data[i]: e for i, e in explanation.details.items()},
        )


#: A predicate that checks if the data is a time.
is_time = is_instance(time, rep='a time')


is_timedelta = is_instance(timedelta, rep='a timedelta')


#: A predicate that checks if the data is a tuple.
is_tuple = is_instance(tuple, rep='a tuple')


class is_tuple_of(is_iterable_of):
    """
    Generates a predicate that checks that the data is a tuple where every
    element of the data is valid according to the given predicate.
    """

    prerequisites = [is_tuple]

    def _evaluate(self, data, explain, context):
        res = super()._evaluate(data, explain, context)
        if explain:
            res.data = tuple(res.data)
        return res


class is_tuple_where(is_iterable_where):
    """
    Generates a predicate that checks that the data is a tuple where the 1st
    element of the data is valid according to the 1st given predicate, the 2nd
    element of the data is valid according to the 2nd given predicate and so
    on. Also requires that the amount of elements in the tuple is equal to the
    amount of predicates given.
    """

    prerequisites = [is_tuple]

    def _evaluate(self, data, explain, context):
        res = super()._evaluate(data, explain, context)
        if explain:
            res.data = tuple(res.data)
        return res


class is_when(Predicate):

    def __init__(self, value, then=is_something, else_=is_nothing):
        self._value = value
        self._then = to_pred(then)
        self._else = to_pred(else_)

    def _evaluate(self, data, explain, context):
        if context(self._value):
            return self._then(data, explain, context)
        else:
            return self._else(data, explain, context)

    @classmethod
    def cases(cls, *cases, default=is_nothing):
        predicate = to_pred(default)
        for cond, then_ in reversed(cases):
            predicate = cls(cond, then_, predicate)
        return predicate


def assert_valid(data, predicate, context={}, message=None):
    """
    Asserts that the data is valid according to the given predicate. If no
    ``message`` is provided to this function the explanation of the predicate
    will be used for the AssertionError in case the assertion fails.
    """
    valid = to_pred(predicate).explain(data, context=context)

    if not valid:
        if message is None:
            message = valid.summary()
        raise AssertionError(message)

    return valid.data

__all__ = [
    Explanation, is_fixed, is_something, is_nothing, is_not, is_all, is_any,
    is_blank, is_not_blank, is_one, is_if, is_cond, is_eq, is_gt, is_geq,
    is_lt, is_leq, is_in_range, is_in, is_none, is_null, is_match,
    is_iterable_where, is_iterable_of, is_dict_where, is_subdict_where,
    is_superdict_where, is_dict_of, is_object_where, is_list_of, is_list_where,
    is_tuple_of, is_tuple_where, is_set_of, is_iterable, is_instance, is_str,
    is_int, is_float, is_bool, is_list, is_dict, is_set, is_tuple, is_datetime,
    is_date, is_time, is_timedelta, is_number, is_json, is_transformed,
    is_json_where, is_optional, is_pre, is_nullable, is_with, is_byte, Get,
    is_bytes, is_decodable, is_decodable_where, is_decodable_json_where,
    is_with_context, is_when, is_dict_union, to_pred,
]
